# lplots Widgets

**Core concept**

* Every widget is a Python object. Assign to a variable; the live user selection is at `.value`.
* Widgets render in **call order**.
* **Reactive execution:** any cell that touches `some_widget.value` re-runs when that value changes. To *read once without reactivity*, use `some_widget._signal.sample()`.

**Common patterns**

```python
# Select
from lplots.widgets.select import w_select
opt = w_select(label="Pick", options=["a","b","c"])
opt.value  # -> "a" | "b" | "c"

# Latch Data file -> pandas
from lplots.widgets.ldata import w_ldata_picker
import pandas as pd
csv = w_ldata_picker(label="CSV", default="latch:///path/file.csv")
df = pd.read_csv(csv.value.download())  # .download() yields local path
```

---

## Inputs

**Datasource picker**

```python
from lplots.widgets.datasource import w_datasource_picker
# default is a discriminated union:
# {"type":"ldata","node_id":str} | {"type":"registry","table_id":str} |
# {"type":"dataframe","key":str} | {"type":"viewer","viewer_id":str}
ds = w_datasource_picker(label="Datasource", default={"type":"ldata","node_id":"95902"})
```

**Registry table → dataframe**

```python
from lplots.widgets.registry import w_registry_table_picker
from latch.registry.table import Table
t = w_registry_table_picker(label="Registry table")
if (tid := t.value): df = Table(id=tid).get_dataframe()
```

**Text / Selectors**

```python
from lplots.widgets.text import w_text_input, w_text_output
name = w_text_input(label="Name", default="Alice"); w_text_output(content="Hi " + name.value)

from lplots.widgets.multiselect import w_multi_select
ms = w_multi_select(label="Tags", options=["alpha","bravo","charlie"])

from lplots.widgets.radio import w_radio_group
rg = w_radio_group(label="One", options=[1,2,3])

from lplots.widgets.checkbox import w_checkbox
cb = w_checkbox(label="Flag")
```

**Appearance (available on most inputs)**

```python
appearance={
  "placeholder":"…","detail":"(info)","help_text":"Help",
  "error_text":"Error","description":"Tooltip"
}
```

---

## Layout

```python
from lplots.widgets.row import w_row
from lplots.widgets.column import w_column
from lplots.widgets.grid import w_grid
# Horizontal
w_row(items=[...])
# Vertical
w_column(items=[...])
# Grid (context manager, supports spans)
with w_grid(columns=12) as g:
    g.add(item=..., col_span=4, row_span=1)
```

* Layouts can be **nested** (rows inside grid cells, etc.).
* Layouts are reactive to child updates.

---

## Outputs

**Plot (matplotlib or plotly)**

```python
from lplots.widgets.plot import w_plot
# IMPORTANT: must be called at **global scope** (not inside a function)
plot = w_plot(label="My Plot", source=fig_or_axes_or_plotly_fig, key=None)
```

**Table (pandas.DataFrame)**

```python
from lplots.widgets.table import w_table
table = w_table(label="Data", source=df, key=None)
```

**H5AD viewer (AnnData / spatial)**

```python
from lplots.widgets.h5 import w_h5
from latch.ldata.path import LPath
viewer = w_h5(
  ann_data=adata,                # or spatial_dir=LPath(...), ann_tiles=LPath(...)
  readonly=False,
  viewer_presets={
    "genes_of_interest":["CD3D","CD4"],
    "default_color_by":{"type":"obs","key":"cell_type"},
    "default_obsm_key":"X_umap",
    "cell_markers":{"default_size":3,"default_opacity":0.8},
    "categorical_color_palette":["red","blue"], "continuous_color_palette":["blue","white","red"]
  }
)
v = viewer.value
# v["lasso_points"]: list[list[(x,y)]], v["lasso_points_obsm"]: str | None
```

**Logs**

```python
from lplots.widgets.logs import w_logs_display
from lplots import submit_widget_state
w_logs_display(); submit_widget_state()
```

---

## Reactivity tip

* Put the **data load widget** in one cell, and **consume `.value`** in a downstream cell to get automatic re-runs when the upstream selection changes. Use `._signal.sample()` in long-running cells to avoid auto re-runs.
