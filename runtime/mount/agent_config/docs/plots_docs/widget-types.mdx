# lplots Widgets

**Core concept**

* Every widget is a Python object. Assign to a variable; the live user selection is at `.value`.
* Widgets render in **call order**.
* **Reactive execution:** any cell that touches `some_widget.value` re-runs when that value changes. To *read once without reactivity*, use `some_widget._signal.sample()`.

**Common patterns**

```python
# Select
from lplots.widgets.select import w_select
opt = w_select(label="Pick", options=["a","b","c"])
opt.value  # -> "a" | "b" | "c"

# Latch Data file -> pandas
from lplots.widgets.ldata import w_ldata_picker
import pandas as pd
csv = w_ldata_picker(label="CSV", default="latch:///path/file.csv")
df = pd.read_csv(csv.value.download())  # .download() yields local path
```

---

## Inputs

**Datasource picker**

```python
from lplots.widgets.datasource import w_datasource_picker
# default is a discriminated union:
# {"type":"ldata","node_id":str} | {"type":"registry","table_id":str} |
# {"type":"dataframe","key":str} | {"type":"viewer","viewer_id":str}
ds = w_datasource_picker(label="Datasource", default={"type":"ldata","node_id":"95902"})
```

**Registry table → dataframe**

```python
from lplots.widgets.registry import w_registry_table_picker
from latch.registry.table import Table
t = w_registry_table_picker(label="Registry table")
if (tid := t.value): df = Table(id=tid).get_dataframe()
```

**Text / Selectors**

```python
from lplots.widgets.text import w_text_input, w_text_output
name = w_text_input(label="Name", default="Alice"); w_text_output(content="Hi " + name.value)

from lplots.widgets.multiselect import w_multi_select
ms = w_multi_select(label="Tags", options=["alpha","bravo","charlie"])

from lplots.widgets.radio import w_radio_group
rg = w_radio_group(label="One", options=[1,2,3])

from lplots.widgets.checkbox import w_checkbox
cb = w_checkbox(label="Flag")
```

**Appearance (available on most inputs)**

```python
appearance={
  "placeholder":"…","detail":"(info)","help_text":"Help",
  "error_text":"Error","description":"Tooltip"
}
```

---

## Layout

```python
from lplots.widgets.row import w_row
from lplots.widgets.column import w_column
from lplots.widgets.grid import w_grid
# Horizontal
w_row(items=[...])
# Vertical
w_column(items=[...])
# Grid (context manager, supports spans)
with w_grid(columns=12) as g:
    g.add(item=..., col_span=4, row_span=1)
```

* Layouts can be **nested** (rows inside grid cells, etc.).
* Layouts are reactive to child updates.

---

## Outputs

### **Plot (matplotlib or plotly)**

```python
from lplots.widgets.plot import w_plot
plot = w_plot(label="My Plot", source=fig_or_axes_or_plotly_fig, key=None)
```

### **Table (pandas.DataFrame)**

```python
from lplots.widgets.table import w_table
table = w_table(label="Data", source=df, key=None)
```

### **H5AD viewer (AnnData / spatial)**

```python
from lplots.widgets.h5 import w_h5
from latch.ldata.path import LPath
viewer = w_h5(
  ann_data=adata,                # or spatial_dir=LPath(...), ann_tiles=LPath(...)
  readonly=False,
  viewer_presets={
    "genes_of_interest":["CD3D","CD4"],
    "default_color_by":{"type":"obs","key":"cell_type"},
    "default_obsm_key":"X_umap",
    "cell_markers":{"default_size":3,"default_opacity":0.8},
    "categorical_color_palette":["red","blue"], "continuous_color_palette":["blue","white","red"]
  }
)
v = viewer.value
# v["lasso_points"]: list[list[(x,y)]], v["lasso_points_obsm"]: str | None
```

### **IGV Viewer (BAM, VCF, BED, BigWig, etc.)**

```python
from lplots.widgets.igv import w_igv, IGVOptions
from latch.account import Account 

workspace_id = Account.current().id

latch_path = f"latch://{workspace_id}.account/Covid/covid.bam"
index_path = f"latch://{workspace_id}.account/Covid/covid.bam.bai"

options: IGVOptions = {
    "genome": "hg38",
    "locus": "chr1:155,100,000-155,200,000",
    "tracks": [
        {
            "name": "Alignment",
            "type": "alignment",
            "url": latch_path,
            "indexURL": index_path,
            "color": "steelblue",
            "height": 150
        }
    ]
}

w_igv(options=options)
```

`options` (required)
Dictionary following [IGV.js Browser Creation](https://igv.org/doc/igvjs/#Browser-Creation) and [Tracks](https://igv.org/doc/igvjs/#tracks/Tracks) schemas.

_Common Browser Options_
- `genome` — Reference genome ID (e.g. "hg38", "mm10").  
- `locus` — Initial genomic locus (e.g. "chr1:100000-200000").  
- `tracks` — List of track configurations.  
- `showNavigation` — Toggle navigation bar (default: True).  
- `showIdeogram` — Toggle ideogram display (default: True).  
- `showRuler` — Show base-pair ruler (default: True).  
- `readOnly` — Disable editing (default: False).  

_Common Track Options_
- `name` — Display name of the track.  
- `type` — Track type (`alignment`, `variant`, `annotation`, `wig`).  
- `url` — Path or URL to data file (`latch://` or public).  
- `indexURL` — Path or URL to index file (`.bai`, `.tbi`, etc.).  
- `color` — Track color (name, hex, or rgb).  
- `height` — Track height in pixels.  
- `displayMode` — "EXPANDED" (default) or "SQUISHED".  
- `autoscale` — Automatically adjust y-axis (for coverage tracks).  
- `visibilityWindow` — Max visible region in base pairs before hiding (default: 100000).  

_Usage Notes_
- Accepts both **Latch paths (`latch://...`)** and public URLs.  
- Automatically generates index files if missing.  

### **Workflow Output Widget (`w_workflow`)**

The `w_workflow` widget launches a Latch Workflow directly from Plots.

```python
from lplots.widgets.workflow import w_workflow

# Launch a workflow with parameters
workflow = w_workflow(
    label="Run Analysis",
    wf_name="my_analysis_workflow",
    params={
        "input_file": "latch://workspace/data/sample.fastq",
        "output_dir": "latch://workspace/results/"
    },
    version="v1.0"
)

execution = workflow.value

if execution is not None:
    res = await execution.wait()
```

#### **Widget Parameters**

- **label** (`str`, required): Button label.  
- **wf_name** (`str`, required): Name of the workflow to execute.  
- **params** (`dict`, required): Dictionary of input parameters.  
- **version** (`str | None`, optional): Workflow version; defaults to latest.  
- **readonly** (`bool`, optional): Disable button if `True`. Defaults to `False`.  
- **key** (`str`, optional): Unique widget identifier.  

#### **Class: `Execution`**

Represents a running or completed workflow execution.

**Attributes**
- `id` (`str`): Unique execution ID.  
- `python_outputs` (`dict[str, type]`): Output names mapped to expected Python types.  
- `status` (`ExecutionStatus`): Current status (`RUNNING`, `FAILED`, `SUCCEEDED`, etc.).  
- `outputs_url` (`str | None`): URL to outputs, if available.  
- `flytedb_id` (`str | None`): FlyteDB ID (updated during polling).  

**Methods**
- `poll()`: Generator that continuously polls execution status.  
- `wait() -> CompletedExecution | None`:  
  Asynchronously waits for execution to complete and returns a `CompletedExecution` object.  
  Returns empty output if status is `FAILED` or `ABORTED`.

#### **Class: `CompletedExecution`**

Represents the final state of an execution.

**Attributes**
- `id` (`str`): Unique execution ID.  
- `output` (`dict[str, Any]`): Processed workflow outputs (populated if succeeded).  
- `ingress_data` (`list[LPath]`): Data written to LData during execution.  
- `status` (`ExecutionStatus`): Final execution status.  

#### **Usage Notes**

- The widget creates a **button** that runs the specified workflow when clicked.  
- `workflow.value` returns an `Execution` object or `None` if not launched.  
- Use `await execution.wait()` to get the final outputs as a `CompletedExecution` object.

### **Logs**

```python
from lplots.widgets.logs import w_logs_display
from lplots import submit_widget_state
w_logs_display(); submit_widget_state()
```

---

## Button

```python
from lplots.widgets.button import w_button

button = w_button(label="Click Button to Run")

if button.value:
  # logic within `if` clause is only run when button is clicked
```

---

## Reactivity tip

* Put the **data load widget** in one cell, and **consume `.value`** in a downstream cell to get automatic re-runs when the upstream selection changes. Use `._signal.sample()` in long-running cells to avoid auto re-runs.
